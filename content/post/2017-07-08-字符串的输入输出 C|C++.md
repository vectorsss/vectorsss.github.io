---
title: "字符串的输入输出 C/C++"
date: "2017-07-08"
categories: 
  - "coding"
tags: 
  - "字符串"
  - "枚举"
url: "/archives/91"
---

## C字符串-字符数组

### 输入输出函数

#### 输入函数

**scanf("%s", s)**

读入字符串，在第一个空白符(' '、'\\n'、'\\t')处停止，不读入空白符，在串尾自动添加'\\0'。(%\*c表示读入并舍弃，可用于"吃掉"末尾的回车)

**gets(s)**

读入一行字符，直到遇到'\\n'，读入换行符并将其舍弃，在串尾自动添加'\\0'。

**c = getchar(), scanf("%c", &c)**

读入下一个字符，包括空白符。

#### 输出函数

- printf() 格式化输出
- puts(s) 输出s串，并在最后自动添加回车'\\n'
- putchar(c) 如果c为字符，输出字符。如果c为整型数字，则会将它看做对应字符的ASCII代码，输出该字符。
    
    ### 常用字符串处理函数
    

**strlen(s)**

最常用的字符串函数，一般紧跟在输入之后，读完字符串后马就上测长度。

**strcmp(s1, s2)**

用来比较两个字符串字典序的大小，即从左到右依次比较每个字符的ACSII 码值，一旦分出大小就不再比较之后的字符。与两个串的长度无关。

**memset() 从内存层面快速初始化**

```
初始化为全0: memset(a, 0, sizeof(a));
初始化为无穷大: memset(a, 0x3f, sizeof(a))
初始化为全-1: memset(a, -1, sizeof(a))
```

a为初始化的首地址。无穷大为什么是0x3f？请见文章末尾  
变量和数组定义后，如果不读入数据，就一定要初始化。

**记得引用头文件#include**

## C++字符串-String对象

### String简介

```
C++、java、VB等编程语言中的名词，用于存储和处理字符串的类。
在java、C#中，String类是不可变的，对String类的任何改变，都是返回一个新的String类对象。
类的实质是一种数据类型，类的实例化是对象。
```

### 输入和输出

C++ 专门的输入输出方法是cin和cout，它兼容C 的所有数据类型，包括字符数组，同时因为string是C++ 特有的类，要输入输出string对象就只能用cin和cout。

使用cin和cout需包含头文件iostream

```
#include 
```

并在代码开头声明名称空间std;

```
using namespace std;
```

**Code**

```
int a;
char s[10];
string str;
cin >> a;
cin >> s >> str;
cout > 可以连接使用
//> 形象表示数据的流向
//endl 相当于'\n'
```

**Input**

```
123
Hello
String
```

**Output**

```
123 HelloString
```

## 常量

```
#define N 100 是文本替换，在所有出现N的地方，都会用100替换。
C++中用const定义常量：const int N=100
const定义的常量有数据类型;
define定义的常量没有数据类型;
编译器可以对前者进行类型安全检查，对后者只是进行无脑替换，可能会出现意想不到的错误。
```

## 关于无穷大0x3f3f3f的一些知识

1. **0x3f3f3f3f**的十进制是**1061109567**，也就是**10^9**级别的（和**0x7fffffff**一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。
2. 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上**0x3f3f3f3f+0x3f3f3f3f=2122219134**，这非常大但却没有超过32-bit int的表示范围，所以**0x3f3f3f3f**还满足了我们“**无穷大加无穷大还是无穷大**”的需求。
3. 最后，**0x3f3f3f3f**还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用**memset(a,0,sizeof(a))**这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为**0x3f3f3f3f**，那么奇迹就发生了，**0x3f3f3f3f**的每个字节都是**0x3f**！所以要把一段内存全部置为无穷大，我们只需要**memset(a,0x3f,sizeof(a))**。  
    **所以在通常的场合下，const int INF = 0x3f3f3f3f0x3f3f3f3f真的是一个非常棒的选择。**
