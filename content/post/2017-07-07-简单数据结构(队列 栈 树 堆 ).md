---
title: "简单数据结构(队列 栈 树 堆 )"
date: "2017-07-07"
categories: 
  - "coding"
tags: 
  - "数据结构"
url: "/archives/93"
---

# 基础知识

## 基本概念

```
    程序 = 算法 + 数据结构

    数据结构是计算机存储、组织数据的方式。

    数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。

    通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。

    数据结构往往同高效的检索算法和索引技术有关。
```

## 常见数据结构

```
    集合：set，multiset

    线性结构：数组、链表、队列、栈

    树形结构：二叉树及其变型，线段树，巴拉巴拉

    图形结构：各种图
```

# 栈和队列

## 栈Stack

```
    先进后出(FILO)
```

![](https://image.i-ll.cc/2021-10-01-125115.png)  

FILO

## 队列Queue

```
    先进先出(FIFO)
```

![](https://image.i-ll.cc/2021-10-01-125125.png)  

FIFO

# 树和堆

## 树的定义

**树（tree）是包含n（n>0）个结点的有穷集，其中：**

1. 每个元素称为结点（node）
2. 有一个特定的结点被称为根结点或树根（root）
3. 除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm-1，其中每一个集合Ti（1
4. 空集也是一棵树  
    **树去掉根节点叫做森林**

### 树的定义的等价命题

- 设G=是n阶m条边的无向图，则下面各命题是等价的：
    - G 是树.
    - G 中任意两个顶点之间存在惟一的路径.
    - G 中无回路且 m=n-1.
    - G 是连通的且 m=n-1.
    - G 是连通的且 G 中任何边均为桥.
    - G 中没有回路，但在任何两个不同的顶点之间加一条新边，在所得图中得到惟一的一个含新边的圈.

## 树的性质

- 如果G是树，那么边数=顶点数-1
- 树中任意两点存在唯一路径
- 树是连通的而且任何边均为桥
- 在树中不同两点加上一个边会得到唯一一个圈

## 二叉树

![](https://image.i-ll.cc/2021-10-01-125136.png)  

二叉树

- 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。
- 一棵深度为k，且有2^(k-1)个节点称之为满二叉树，一棵二叉树第i层最多有2^(i-1)个节点；
- 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为**完全二叉树**。

**任何一个包含n个节点完全二叉树(满足从根节点开始，依次从上往下，从左往右遍历子节点，进行标记。如上图)，对于任何下标为i的节点来说，1≤i≤n 有：**

- 当i≠1时，parent(i)在⌊i/2⌋.i=1时,i是树根，没有父节点。
- 当2i≤n时，lchild(i)在2i。2i>n，i没有左孩子。
- 当2i+1≤n时，rchild(i)在2i+1.2i+1>n,i没有右孩子。

## 堆(Heap)

- 最大堆:每个节点的值都大于等于它的孩子节点。
- 最小堆:每个节点的值都小于等于它的孩子节点。

### 堆的存储

- 可以理解为二叉树的一种，是节点间有序关系的完全二叉树，所以可以用**数组**来表示。
- 对于下标为i的节点，它的子树的左节点的下标为2_i,右节点为2_i+1，父亲的节点下标为i/2（向下取整）。
- 在程序设计中，使用位运算来代替直接\*2可以提高运行速度。-
- 某些编译器中会把一些特定的乘法运算改写为位运算。

# 前缀、中缀、后缀表达式转换与求值

- **前缀表达式**：运算符位于操作数之前。
- **中缀表达式**：操作符处于操作数的中间。中缀表达式是人们常用的算术表示方法。(但是计算机计算中缀表达式是复杂的，所以一般需要将中缀表达式转换成前缀或者后缀表达式)
- **后缀表达式**：运算符位于操作数之后。

**举例：**  
(3+4)×5-6 中缀表达式  
\-×+3456 前缀表达式  
34+5×6- 后缀表达式

**前缀表达式的计算机求值：**

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。  
例如前缀表达式“- × + 3 4 5 6”：

1. 从右至左扫描，将6、5、4、3压入堆栈；
2. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；
3. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。

**后缀表达式的计算机求值：**

与前缀表达式类似，只是顺序是从左至右：  
从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。  
例如后缀表达式“3 4 + 5 × 6 -”：

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。

**将中缀表达式转换为前缀表达式：**

1. 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
2. 从右至左扫描中缀表达式；
3. 遇到操作数时，将其压入S2；
4. 遇到运算符时，比较其与S1栈顶运算符的优先级：
    - 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；
    - 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；
    - 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到4-1与S1中新的栈顶运算符相比较；
5. 遇到括号时：
    - 如果是右括号“)”，则直接压入S1；
    - 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；
6. 重复步骤(2)至(5)，直到表达式的最左边；
7. 将S1中剩余的运算符依次弹出并压入S2；
8. 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。

**将中缀表达式转换为后缀表达式：**

1. 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压入S2；
4. 遇到运算符时，比较其与S1栈顶运算符的优先级：
    - 如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
    - 否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；
    - 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到4-1与S1中新的栈顶运算符相比较；
5. 遇到括号时：
    - 如果是左括号“(”，则直接压入S1；
    - 如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；
6. 重复步骤(2)至(5)，直到表达式的最右边；
7. 将S1中剩余的运算符依次弹出并压入S2；
8. 依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）。
